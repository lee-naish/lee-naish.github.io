<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="keywords" content="adtpp, algebraic data types, C, manual">
<meta name="description" content="adtpp tool documentation">
<meta name="maintained-by" content="Lee Naish dr.lee.naish@gmail.com">
<meta name="expiry-date" content="9999-12-31">
<title>How to use adtpp</title>
<link rev=made href="dr.lee.naish@gmail.com">
</head>
<body>
<h1>How to use <code>adtpp</code></h1>
<h2>Overview</h2>

<p> <code>adtpp</code> provides support for algebraic data types
in C. Type information is put in a file with a <code>.adt</code>
extension and <code>adtpp</code> processes this to produce a C header
file which contains C type definitions, macros etc to be used in C
code. The following command takes <code>example.adt</code> and produces
<code>example.h</code>:
</p>

<pre>
adtpp example.adt
</pre> 

<p> If you prefer to read code with comments, you can take a look at <a
href="./example.adt.txt"> example.adt</a> and <a href="example.c.txt">
example.c</a> that uses it. There is also a <a href="./paper.pdf">
paper</a> about the system that gives more background, motivation and
discussion of implementation, performance etc. Here we first describe how
simple algebraic data types are defined and used, then discuss polmorphic
(generic) types, higher order code (pointers to functions).  We finish
with a <a href="#reference">quick reference</a> for <code>adtpp</code>
features.
</p>

<h2>Simple ADTs</h2>

<p>
ADTs are defined using <code>data</code> declarations such as the
following:
</p>
<pre>
data point {
    Point(double, double);
}
data color {
    Red();
    Blue();
    Green();
}
data tree {
    Empty();
    Node(long, tree, tree);
}
data quad_roots {
    Noroot();
    Oneroot(double);
    Tworoot(double, double);
}
</pre>

<p> The first defines the type <code>point</code> that has a single
data constructor, <code>Point</code> with two arguments, both of
type <code>double</code>. Identifiers are case sensitive and here
we use upper case for data constructors by convention - any valid C
identifier can be used for both  types and data constructors.  'data'
is a keyword for parsing by <code>adtpp</code> and white-space is not
significant. The arguments of data constructors in such definitions
should be valid types. Those not defined in the file (for example,
<code>double</code>) are assumed to be defined elsewhere in C. Parsing
compound C type expressions such as pointers, structs, arrays etc is not
supported; if this is desired <code>typedef</code> or <code>#define</code>
can be used in C code to give a single identifier name to the type.
As the other <code>data</code> declarations above show, types can be
defined recursively, there can be multiple data constructors in a type
and those that have no arguments must still be followed by parentheses.
</p>

<p> ADT values are created/constructed by using the data constructors like
C functions calls (the C compiler checks the argument and result types as
it would with other function calls). For data constructors with arguments,
this dynamically allocates memory, using <code>ADT_MALLOC</code> (defined
as <code>malloc</code> by default).  For each type <code>mytype</code>,
a function <code>free_mytype</code> is generated that frees the memory
allocated by the top level data constructor (using <code>ADT_FREE</code>;
it does not recursively process arguments of the data constructor).  The
code can also easily be used with different memory management libraries,
including garbage collection (which we recommend).  For example:
</p>

<pre>
#include "example.h" // generated by "adtpp example.adt"
...
    point origin;                // defines variable origin of type point
    tree t1, t2, t3;
    origin = Point(0.0, 0.0);    // creates a point and assigns it to origin
    t1 = Empty();
    t2 = Node(1, t1, Empty());
    t3 = Node(2, t2, t2);
...
    free_tree(t3);              // free memory for t3 only
</pre>

<p> ADT values can be tested and deconstructed (to give access to the
arguments of data constructors) using several programming constructs
based on <code>if-then-else</code> and <code>switch</code>. For each data
constructor <code>MyDC</code> there is an <code>if_MyDC(...)</code>
and <code>else_if_MyDC(...)</code> macro. There is also an
<code>else()</code> and <code>end_if()</code> common to all ADTs.
Arguments of <code>if_MyDC(...)</code> must be an expression of
the correct type plus fresh variables for each of the arguments of
<code>MyDC</code> (the body of the <code>if_MyDC(...)</code> is a new
scope; variables with the same identifier elsewhere are unaffected).
Arguments of <code>else_if_MyDC(...)</code> are the same, except
the first argument is omitted - the whole <code>if-then-else</code>
construct branches on the data constructors of the single value given
in the <code>if_MyDC(...)</code>. For example, in the following code,
<code>else_if_Node(val,tl,tr)</code> is implicitly testing <code>t3</code>
and introduces the three variables, whose scope ends at the final
<code>end_if()</code>. However, <code>if_Node(tl,val,tll,tlr)</code>
introduces another variable called <code>val</code>, whose scope ends
at the <code>else()</code>.
</p>

<pre>
if_Empty(t3)
    printf("Tree is empty\n");
else_if_Node(val, tl, tr)    // implicitly testing t3
    printf("The root is %ld\n", val);
    if_Node(tl, val, tll, tlr) // fresh variable val
        printf("The left sub-tree root is ");
        printf("%ld\n", val);
    else()
        printf("Left sub-tree is empty\n);
    end_if()
end_if()
</pre>	

<p> Braces are not required around compound statements (such as the
consecutive <code>printf</code> statements), semicolons may be used after
the various macros but are not required but the <code>end_if()</code>
is required (the macros use unbalanced braces and the C compiler will
issue a possibly cryptic syntax error message otherwise). The different
data constructors used in one <code>if-then-else</code> construct must be
of the same type (otherwise the C compiler will issue a possibly cryptic
type error message). There are also <code>if_MyDC_ptr(...)</code> and
<code>else_if_MyDC_ptr(...)</code> macros that bind the fresh variable to
pointers to the data constructor arguments; this is the only mechanism
for in-situ update of ADT values.  For example, the root of a tree can
be incremented as follows:
</p>

<pre>
if_Node(t3, valp, tlp, trp)
    *valp++;
else()
    printf("No root to increment\n");
end_if()
</pre>

<p> For each type <code>mytype</code> there is a
<code>switch_mytype(v)</code> macro (where <code>v</code> must have
this type) generated and there is an <code>end_switch()</code>
macro. For each data constructor <code>MyDC</code> there is are
<code>case_MyDC(...)</code> and <code>case_MyDC_ptr(...)</code> macros,
with fresh variables for each of the arguments of <code>MyDC</code>,
with scope limited to that case. there is also a <code>default()</code>
case that can be used. For example, the sum of the elements in a tree
can be computed using the following function:
</p>

<pre>
long sum_tree(tree t) {
    switch_tree(t)
    case_Empty()
        return 0;
    case_Node(val, tl, tr)
        return val + sum_tree(tl) + sum_tree(tr);
    end_switch()
}
</pre>

<h2>Polymorphic (generic) types and functions</h2>

<p> Polymorphic types such as "list of t", where t is a type variable
that can be instantiated to a type allows re-use of type definitions.
Similarly, functions that operate on any list facilitate code reuse.
In <code>adtpp</code>, polymorphism is supported but each instance of
a polymorphic type and function must be declared and given a distinct
identifier in order for errors to be detected using the simple type
system of C. For the same reason, data constructors of different
instances of polymorpihic types must have different names. Type
parameters are allowed in <code>data</code> declarations surrounded
by "angle brackets" to define polymorhic types and their instances
are declared using <code>type</code> declarations (examples below).
Type parameters <em>must</em> be instantiated by ADTs or C types which
are the size of a pointer (<code>adt_int</code> is a predefined integer
type of the correct size, the same as <code>intptr_t</code>; using
<code>list&lt;int&gt;</code> instead of <code>list&lt;adt_int&gt;</code>
may not work <em>and there is no checking for this</em>).
</p>

<pre>
data pair&lt;t1, t2&gt; { Pair(t1, t2); }
data list&lt;t&gt; {
    Nil();
    Cons(t, list&lt;t&gt;);
}

type points = list&lt;point&gt;;
type colors = list&lt;color&gt;;
type ints = list&lt;adt_int&gt;;
type polygon = pair&lt;color, points&gt;;
type polygons = list&lt;polygon&gt;;
type pairs&lt;t1, t2&gt; = list&lt;pair&lt;t1, t2&gt;&gt;;
type polygons1 = pairs&lt;color, points&gt;;
</pre>

<p> Note that <code>data</code> declarations can introduce
new polymorphic types such as <code>pairs</code>.  Also,
distinct identifiers can be given to equivalent types: both
<code>polygons</code> and <code>polygons1</code> are equivalent to
<code>list&lt;pair&lt;color,list&lt;point&gt;&gt;&gt;</code>. With
<code>adtpp</code> these types can be used interchangably.  For instances
of polymorphic types, <code>adtpp</code> essentially generates a copy
of the polymorphic definition with data constructor names having an
underscore followed by the type instance name appended.  For example,
<code>ints</code> has data constructors <code>Nil_ints</code> and
<code>Cons_ints</code> and is defined as follows and macros etc are
generated as if this was defined explicitly:
</p>

<pre>
data ints {      // implicitly generated by adtpp
    Nil_ints();
    Cons_ints(adt_int, ints);
}
</pre>

<p> Data constructors from polymorphic type definitions can be used to
define polymorphic C functions.  For example, functions than compute
the length of a list and concatenate two lists can be defined as follows:
</p>

<pre>
int length(list xs) {
    int len = 0;
    while (1) {
        if_Cons(xs, head, tail)
            len++;
            xs = tail;
        else()
            return len;
        end_if()
   }
}

list concat(list xs, list ys) {
    if_Cons(xs, head, tail)
        return Cons(head, concat(tail, ys));
    else()
        return ys;
    end_if()
}
</pre>

<p>
Polymorphic functions must be declared in the <code>.adt</code> file using
<code>function</code> declarations, giving the type of the arguments and
result, and every distinct type instance that is used must
be given a name with an <code>instance</code> declaration. Having
instances with different names allows the C compiler to perform
appropriate type checking; <code>adtpp</code> generates function
prototypes and definitions for the instances (which call the polymorphic
code). For example, the following declarations allow us to use a
function <code>count_ints</code> which takes an argument of type
<code>ints</code> and returns an <code>int</code> without duplicating
the <code>length</code> code or using error-prone and potentially unsafe
explicit casts.
</p>

<pre>
function&lt;t&gt; int length(list&lt;t&gt;);
instance count_ints = length&lt;adt_int&gt;;

function&lt;t&gt; list&lt;t&gt; concat(list&lt;t&gt;, list&lt;t&gt;);
instance join = concat&lt;point&gt;;
instance concat_col = concat&lt;color&gt;;
</pre>	

<h2>Multiple type parameters</h2>

<p> With types and code that have multiple type parameters, we sometimes
have generic types that differ only in the order of the parameters.
For example, we maye have a polymorphic function <code>swap</code>
that takes an argument of type pair&lt;t1,t2&gt; and returns a result
of type pair&lt;t2,t1&gt;.  Type variables in <code>adtpp</code> are
implemented by using multiple distinct generic types, <code>adt_1</code>,
<code>adt_2</code>, etc. (they have no supported operations). Polymorphic
types are simulated by instantiating type parameters by these generic
types, in order.  For example, in the polymorphic type <code>pair</code>,
the arguments of the <code>Pair</code> data constructor are of type
<code>adt_1</code> and <code>adt_2</code>, respectively. These generic
types can be used explicitly in <code>adtpp</code> declarations to
give distinct names to polymorhic types that differ only in their
parameters. For example:
</p>

<pre>
function&lt;t1, t2&gt; pair&lt;t2, t1&gt; swap(pair&lt;t1, t2&gt;);
instance swap_polygon = swap&lt;points, color&gt;;

type pair_swp = pair&lt;adt_2, adt_1&gt;;     // type returned by swap
type polygon_swp = pair&lt;points, color&gt;; // type returned by swap_polygon
</pre>	

<h2>Higher order types and functions (pointers to functions)</h2>

<p>
Functions can be included in <code>atdpp</code> data types and allowed
as arguments and results of declared functions, using the
<code>func</code> keyword: <code>t_res func(t1, t2)</code> means a
function taking two arguments of type <code>t1</code> and
<code>t2</code>, respectively, and returning a result of type
<code>t_res</code>. For example, we can declare an analogue of the
Haskell polymorphic <code>zipWith</code> function (which takes a
two-argument function <code>f</code> plus two lists and applies
<code>f</code> 
to elements of the two lists pair-wise and returns the list of results).
</p>

<pre>
function&lt;t1,t2,t3&gt;
    list&lt;t3&gt; zipWith(t3 func(t1,t2), list&lt;t1&gt;, list&lt;t2&gt;);
instance mk_polygons = zipWith&lt;color, points, polygon&gt;;

type pointss = list&lt;points&gt;; // needed for mk_polygons
type list_2 = list&lt;adt_2&gt;;   // needed for zipWith
type list_3 = list&lt;adt_3&gt;;   // needed for zipWith
</pre>

<a name="reference"></a>
<h2>Quick reference</h2>

<p>
Command to generate <code>example.h</code> from <code>example.adt</code>:
</p>

<pre>
adtpp example.adt
</pre>

<p> <code>data</code>, <code>type</code>, <code>function</code>
and <code>instance</code> definitions/declarations in
<code>example.adt</code>:
</p>

<pre>
// data types predefined by adtpp:
// numeric: adt_int, adt_uint, adt_char, adt_float
// character pointer: adt_string
// generic types for polymorphism: adt_1, adt_2, adt_3, ...
// Any other identifier used as a type and not defined in example.adt
// is assumed to be defined in C before example.h is included.
// All types defined by adtpp can be used to instantiate polymorphic types
// safely; other types used to instantiate polymorphic types *must* be
// the size of a pointer.

data tree {                   // defines algebraic data type tree
    Empty();                  // data constructor with no arguments
    Node(long, tree, tree);   // data constructor with three arguments
}

data list&lt;t&gt; {                // polymorphic list
    Nil();
    Cons(t, list&lt;t&gt;);
}

// An instance of list&lt;t&gt; (note list&lt;int&gt; should not be used -
// arguments of polymorphic types should be guaranteed to be the same size
// as a pointer to void but adtpp cannot check this)
type ints = list&lt;adt_int&gt;;
// data ints {                // implicitly generated by adtpp
//     Nil_ints();            // type name appended to constructor names
//     Cons_ints(adt_int, ints);
// }

data pair&lt;t1, t2&gt; {            // polymorphic pair
    Pair(&lt;t1&gt;, &lt;t2&gt;);
// data pair {                // implicitly generated by adtpp
//     Pair(adt_1, adt_2);    // parameter(s) replaced by adt_1, adt_2 etc
// }

type pair_swp = pair&lt;adt_2, adt_1&gt;;     // explicit use of adt_1 etc

// Higher order type instance: a list of (int to int) functions
type fns = list&lt;int func(int)&gt;;

function&lt;t&gt; int length(list&lt;t&gt;); // Declares a polymorphic function
instance count_ints = length&lt;adt_int&gt;; // An instance of length

</pre>

<p>
Using the generated code in <code>example.c</code>:
</p>

<pre>
// define identifier myCtype using typedef if you want to use this
// type in ADT definitions - adtpp can't parse complex C types
typedef struct mystruct{int f1[5]; char f2[8]} myCtype;

// redefine malloc/free primitives if desired
#define ADT_MALLOC(s) my_malloc(s)
#define ADT_FREE(s) my_free(s)

// include generated example.h (this includes &lt;stdint.h&gt; and
// &lt;stdlib.h&gt;)
#include "example.h"

// Assuming an ADT named myADT and data constructor MyDC(t1, t2) are
// defined in example.adt, the following functions can be used:
// MyDC(val1, val2)          // create a value (allocates space)
// free_myADT(myADTval)      // free space of top level data constructor
// Also, the following macros can be used to structure code:
// if_MyDC(myADTval, var1, var2)
// if_MyDC_ptr(myADTval, ptr1, ptr2)
// else_if_MyDC(var1, var2)
// else_if_MyDC_ptr(ptr1, ptr2)
// else()
// end_if()
// switch_myADT(myADTval)
// case_MyDC(var1, var2)
// case_MyDC_ptr(ptr1, ptr2)
// default()
// end_switch()

// Example code using ADT tree:
long sum_tree(tree t) {
    switch_tree(t)
    case_Empty()
        return 0;
    case_Node(val, tl, tr)
        return val + sum_tree(tl) + sum_tree(tr);
    end_switch()
}

// Example polymorphic code: return length of a list of anything
// Assuming length has been declared using a function declaration,
// and count_ints is declared as an instance, example.h will contain
// function prototypes for both functions plus a definition of
// count_ints that calls length
int length(list xs) {
    int len = 0;
    while (1) {
        if_Cons(xs, head, tail)
            len++;
            xs = tail;
        else()
            return len;
        end_if()
   }
}

// Return sum of elements in a list of integers (note constructor names
// have _ints appended).
int sumlist(ints xs) {
    if_Cons_ints(xs, head, tail)
        return head + sumlist(tail)
    else()
        return 0;
    end_if()
}



</pre>

</body>
</html>
